//! Parser struct definitions


use scriptkiddie_lexer::token::{Keyword, Token, TokenType};

use crate::ast::ASTNode;

pub mod declaration;
pub mod expression;

/// A result with error type Parsing Error
pub type Result<T> = std::result::Result<T, AstParseError>;

/// An error returned by parsing a tokenstream to an AST
#[derive(thiserror::Error, Debug)]
pub enum AstParseError {
    /// Unexpected EOF error while parsing
    #[error("File ended while parsing midway through a statement")]
    UnexpectedEof,
    /// When a token is not expected
    #[error("Unexpected token {0:?}")]
    UnexpectedToken(Token),
    /// When a token pattern is not registered and therefore cannot be constructed into an ASTNode
    #[error("Token pattern not recognized")]
    UnknownTokenPattern,
}

/// A parser that holds onto a mutable context of a Lexer
pub struct Parser<'lex> {
    /// The internal lexer session
    tokens: &'lex [Token],
    /// The current token we're pointing at
    place: usize
}

impl<'lex> Parser<'lex> {
    /// Creates a new parser session from a token array
    pub fn new(tokens: &'lex [Token]) -> Self {
        Self { tokens, place: 0 }
    }

    /// Gets the current token that's being pointed to
    pub(crate) fn place(&self) -> Option<Token> {
        self.tokens.get(self.place).cloned()
    }

    /// Advances the pointer by 1
    pub(crate) fn advance(&mut self) {
        self.place+=1
    }

    /// Advances the pointer by 1 and then gets the current token that's being pointed to
    pub(crate) fn next(&mut self) -> Option<Token> {
        self.advance();
        self.place()
    }

    /// Looks forward by n and then gets the current token that's being pointed to
    pub(crate) fn peek(&self, n: usize) -> Option<Token> {
        let idx = self.place + n;
        self.tokens.get(idx).cloned()
    }

    /// Parses the tokens generated by the lexer and returns an AST
    pub fn parse_program(&mut self) -> Result<ASTNode> {
        let mut body = vec![];
        while self.place().is_some() {
            body.push(self.parse_statement()?)
        }

        Ok(ASTNode::Program(body))
    }

    /// Parses a single statement as an ASTNode
    pub fn parse_statement(&mut self) -> Result<ASTNode> {
        match self.place() {
            Some(token) => match &token.token_type {
                TokenType::Keyword(Keyword::Let)
                | TokenType::Keyword(Keyword::Const)
                | TokenType::Keyword(Keyword::Var) => self.parse_declaration(),
                _ => self.parse_expression(),
            },
            None => Err(AstParseError::UnexpectedEof),
        }
    }
}
