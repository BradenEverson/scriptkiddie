//! Parser struct definitions

use std::iter::Peekable;

use scriptkiddie_lexer::{
    lexer::Lexer,
    token::{Keyword, Token, TokenType},
};

use crate::ast::ASTNode;

pub mod declaration;
pub mod expression;

/// A result with error type Parsing Error
pub type Result<T> = std::result::Result<T, AstParseError>;

/// An error returned by parsing a tokenstream to an AST
#[derive(thiserror::Error, Debug)]
pub enum AstParseError {
    /// Unexpected EOF error while parsing
    #[error("File ended while parsing midway through a statement")]
    UnexpectedEof,
    /// When a token is not expected
    #[error("Unexpected token {0:?}")]
    UnexpectedToken(Token)
}

/// A parser that holds onto a mutable context of a Lexer
pub struct Parser<'lex> {
    /// The internal lexer session
    lexer: Peekable<&'lex mut Lexer>,
}

impl<'lex> Parser<'lex> {
    /// Creates a new parser session from a lexer
    pub fn from_lexer(lexer: &'lex mut Lexer) -> Self {
        Self {
            lexer: lexer.peekable(),
        }
    }

    /// Parses the tokens generated by the lexer and returns an AST
    pub fn parse_program(&mut self) -> Result<ASTNode> {
        let mut body = vec![];
        while self.lexer.peek().is_some() {
            body.push(self.parse_statement()?)
        }

        Ok(ASTNode::Program(body))
    }

    /// Parses a single statement as an ASTNode
    pub fn parse_statement(&mut self) -> Result<ASTNode> {
        match self.lexer.peek() {
            Some(token) => match &token.token_type {
                TokenType::Keyword(Keyword::Let)
                | TokenType::Keyword(Keyword::Const)
                | TokenType::Keyword(Keyword::Var) => {
                    self.parse_declaration()
                }
                _ => self.parse_expression(),
            },
            None => Err(AstParseError::UnexpectedEof),
        }
    }
}
